"use strict";
// Copyright IBM Corp. 2019,2020. All Rights Reserved.
// Node module: @loopback/repository
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultHasManyThroughRepository = void 0;
const __1 = require("../..");
/**
 * a class for CRUD operations for hasManyThrough relation.
 *
 * Warning: The hasManyThrough interface is experimental and is subject to change.
 * If backwards-incompatible changes are made, a new major version may not be
 * released.
 */
class DefaultHasManyThroughRepository {
    constructor(getTargetRepository, getThroughRepository, getTargetConstraint, getThroughConstraint, getThroughFkConstraint) {
        this.getTargetRepository = getTargetRepository;
        this.getThroughRepository = getThroughRepository;
        this.getTargetConstraint = getTargetConstraint;
        this.getThroughConstraint = getThroughConstraint;
        this.getThroughFkConstraint = getThroughFkConstraint;
    }
    async create(targetModelData, options) {
        var _a;
        const targetRepository = await this.getTargetRepository();
        const throughRepository = await this.getThroughRepository();
        const targetInstance = await targetRepository.create(targetModelData, options);
        const targetConstraint = this.getThroughFkConstraint(targetInstance);
        const throughConstraint = this.getThroughConstraint();
        const constraints = { ...targetConstraint, ...throughConstraint };
        await throughRepository.create(__1.constrainDataObject((_a = options === null || options === void 0 ? void 0 : options.throughData) !== null && _a !== void 0 ? _a : {}, constraints), options === null || options === void 0 ? void 0 : options.throughOptions);
        return targetInstance;
    }
    async find(filter, options) {
        const targetRepository = await this.getTargetRepository();
        const throughRepository = await this.getThroughRepository();
        const throughConstraint = this.getThroughConstraint();
        const throughInstances = await throughRepository.find(__1.constrainFilter(undefined, throughConstraint), options === null || options === void 0 ? void 0 : options.throughOptions);
        const targetConstraint = this.getTargetConstraint(throughInstances);
        return targetRepository.find(__1.constrainFilter(filter, targetConstraint), options);
    }
    async delete(where, options) {
        const targetRepository = await this.getTargetRepository();
        const throughRepository = await this.getThroughRepository();
        const throughConstraint = this.getThroughConstraint();
        const throughInstances = await throughRepository.find(__1.constrainFilter(undefined, throughConstraint), options === null || options === void 0 ? void 0 : options.throughOptions);
        const targetConstraint = this.getTargetConstraint(throughInstances);
        // delete throughs that have the targets that are going to be deleted
        const throughFkConstraint = this.getThroughFkConstraint(targetConstraint);
        await throughRepository.deleteAll(__1.constrainWhereOr({}, [throughConstraint, throughFkConstraint]));
        // delete target(s)
        return targetRepository.deleteAll(__1.constrainWhere(where, targetConstraint), options);
    }
    // only allows patch target instances for now
    async patch(dataObject, where, options) {
        const targetRepository = await this.getTargetRepository();
        const throughRepository = await this.getThroughRepository();
        const throughConstraint = this.getThroughConstraint();
        const throughInstances = await throughRepository.find(__1.constrainFilter(undefined, throughConstraint), options === null || options === void 0 ? void 0 : options.throughOptions);
        const targetConstraint = this.getTargetConstraint(throughInstances);
        return targetRepository.updateAll(__1.constrainDataObject(dataObject, targetConstraint), __1.constrainWhere(where, targetConstraint), options);
    }
    async link(targetModelId, options) {
        throw new Error('Method not implemented.');
    }
    async unlink(targetModelId, options) {
        throw new Error('Method not implemented.');
    }
}
exports.DefaultHasManyThroughRepository = DefaultHasManyThroughRepository;
//# sourceMappingURL=has-many-through.repository.js.map